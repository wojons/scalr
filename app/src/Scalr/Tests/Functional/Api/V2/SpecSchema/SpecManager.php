<?php

namespace Scalr\Tests\Functional\Api\V2\SpecSchema;

use Scalr\Tests\Functional\Api\V2\SpecSchema\DataTypes\DetailsResponse;
use Scalr\Tests\Functional\Api\V2\SpecSchema\DataTypes\ListResponse;
use Scalr\Tests\Functional\Api\V2\SpecSchema\DataTypes\Property;
use Scalr\Tests\Functional\Api\V2\SpecSchema\DataTypes\AbstractSpecObject;
use Scalr\Util\Api\Describer;
use Scalr\Exception\FileNotFoundException;
use InvalidArgumentException;
use Scalr\System\Config\Yaml;

/**
 * Generate SpecObject from swagger specifications
 *
 * @author Andrii Penchuk <a.penchuk@scalr.com>
 * @since 5.11 (03.12.2015)
 */
class SpecManager
{
    /**
     * Spec file path
     *
     * @var string
     */
    private $specFile;

    /**
     * Api definitions
     *
     * @var mixed array
     */
    private $specification;

    /**
     * SpecManager constructor.
     *
     * @param string $version Api version
     * @param string $service spec file service
     * @throws FileNotFoundException
     */
    public function __construct($version, $service)
    {
        if (!(preg_match("/^" . Describer::VERSION_NAME_REGEXP . "$/", $version) && preg_match("/^" . Describer::SERVICE_NAME_REGEXP . "$/", $service))) {
            throw new FileNotFoundException("{$service}.{$version}");
        }

        $file = "{$version}/{$service}-autogenerated.yaml";
        $this->specFile = realpath(APPPATH . "/../api/{$file}");
        if (!$this->specFile) {
            throw new FileNotFoundException("{$service}.{$version}", "Api {$version} specification not found for service '{$service}'");
        }

        $this->specification = Yaml::load($this->specFile)->toArray();
    }

    /**
     * The list of endpoints in Api specifications
     * @param string $method HTTP method
     *
     * @return string[]
     */
    public function getPathTemplates($method = null)
    {
        if (!is_null($method)) {
            $method = strtolower($method);
            $paths = array_filter($this->specification['paths'], function ($v) use ($method) {
                return array_key_exists($method, $v) && array_key_exists(200, $v[$method]['responses']);
            });
        } else {
            $paths = $this->specification['paths'];
        }
        return array_keys($paths);
    }

    /**
     * Get Object definition
     *
     * @param string $filter optional The pattern to filter for object definition in specification
     * if the name of the object matched the filter this object will not be included in return result
     *
     * @return array
     */
    public function getDefinitions($filter = null)
    {
        $definitions = $this->getPath('definitions');

        if (!is_null($filter)) {
            $definitions = array_filter($definitions, function ($k) use ($filter) {
                return !preg_match($filter, $k);
            }, ARRAY_FILTER_USE_KEY);
        }

        foreach ($definitions as $name => $definition) {
            $definitions[$name] = $this->resolveReferences($definition, null, $name);
        }

        return $definitions;
    }

    /**
     * Get Response definitions with Api endpoint
     *
     * @param string $path     Api endpoint
     * @param string $method   HTTP method
     * @param int    $httpCode HTTP code
     * @return DetailsResponse|ListResponse
     */
    public function getResponse($path, $method, $httpCode)
    {
        $this->checkPath($path);
        return $this->resolveReferences(
            $this->getPath('paths', $path, strtolower($method), 'responses', $httpCode, 'schema')
        );
    }

    /**
     * Return endpoint parameters
     *
     * @param string $path Api endpoint
     * @return array
     */
    public function getPathParameters($path)
    {
        $this->checkPath($path);
        return $this->getPath('paths', $path, 'parameters');
    }

    /**
     * Return Api definitions from segment
     *
     * @param string[] $segments patch segments
     * @return array
     */
    protected function getPath(...$segments)
    {
        $result = $this->specification;
        foreach ($segments as $segment) {
            if (!isset($result[$segment])) {
                throw new InvalidArgumentException(
                    sprintf('Missing segment %s in %s spec file %s', $segment, implode('/', $segments), $this->specFile)
                );
            }
            $result = $result[$segment];
        }
        return $result;
    }

    /**
     * Resolve schema references to object
     *
     * @param array $schema               segment Api specifications
     * @param mixed $specObject optional  object schema view
     * @param mixed $objectName optional  object property name
     * @return DetailsResponse|ListResponse
     */
    protected function resolveReferences($schema, $specObject = null, $objectName = null)
    {
        $ref = '$ref';
        if (array_key_exists($ref, $schema)) {
            $refPath = explode('/', ltrim($schema[$ref], '#/'));
            unset($schema[$ref]);
            $object = AbstractSpecObject::init($refPath[1]);
            if (is_null($specObject)) {
                $specObject = $object;
            } else {
                $specObject->entity = $object;
                foreach ($schema as $key => $value) {
                    $specObject->$key = $value;
                }
            }
            $schema = $this->getPath(...$refPath);
        } else {
            if (is_null($specObject)) {
                $specObject = AbstractSpecObject::init($objectName);
            }
            $object = $specObject;
        }

        if (array_key_exists('items', $schema)) {
            $object->items = $this->resolveReferences($schema['items'], null, $object->getObjectName());
            unset($schema['items']);
        }

        if (array_key_exists('properties', $schema)) {
            foreach ($schema['properties'] as $nameProp => $prop) {
                if (!array_key_exists('type', $prop)) {
                    $prop['type'] = $nameProp;
                }
                $object->$nameProp = $this->resolveReferences($prop, new Property($nameProp));
            }
            unset($schema['properties']);
        }

        if (array_key_exists('x-concreteTypes', $schema)) {
            foreach ($schema['x-concreteTypes'] as $prop) {
                $enumObject = $this->resolveReferences($prop);
                $object->concreteTypes[$enumObject->getObjectName()] = $enumObject;
            }
            unset($schema['x-concreteTypes']);
        }

        foreach ($schema as $key => $value) {
            $object->$key = $value;
        }

        return $specObject;
    }

    /**
     * Check if path not exist, will throw exception
     *
     * @param string $path path in Api specifications
     */
    protected function checkPath($path)
    {
        if (!in_array($path, $this->getPathTemplates())) {
            throw new InvalidArgumentException("$path don't exist in {$this->specFile}");
        }
    }
}